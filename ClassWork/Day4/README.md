> **Материал подготовлен преподавателем Комаров Иван Николаевич по курсу "Платформа Microsoft.NET и язык программирования С#". Учебное заведение "Компьютерная Академия Шаг".**

Введение в классы
===

**`Объектно-ориентированное программирование (ООП)`** — парадигма программирования, в которой основными концепциями являются понятия объектов и классов.

Введение в ООП. Парадигмы ООП
---

1. [**Инкапсуляция**](https://github.com/SuvStreet/IT_Step_Cpp/tree/master/ClassWork/Lesson1#Инкапсуляция)
* Сокрытие типов
* Сокрытие реализации
* Сокрытие частей программных систем

2. [**Наследование**](https://github.com/SuvStreet/IT_Step_Cpp/tree/master/ClassWork/Lesson1#Наследование)

3. [**Полиморфизм**](https://github.com/SuvStreet/IT_Step_Cpp/tree/master/ClassWork/Lesson1#Полиморфизм)
* использование виртуальных членов, приведение типов, перегрузка операторов и методов

4. ***Абстракция***
* формирование собирательных понятий

5. ***Посылка сообщений***
* организация информационных потоков между объектами

6. ***Повторное использование***
* использование методов, классов, структур, наследования, Библиотек, Фреймворков

![](https://pp.userapi.com/c837323/v837323690/5857b/4LUdV3-jBxE.jpg)

Синтаксис объявления класса
---

```cs
[cпецификатор] [модификатор] class имя_класса
{

// объявление полей класса
    [cпецификатор] [модификатор] тип имя_поля1;
    [cпецификатор] [модификатор] тип имя_поля2;
    ...
    [cпецификатор] [модификатор] тип имя_поляN;
    
// объявление конструкторов
    [cпецификатор] [модификатор] имя_конструктора1 (список параметров)
    { 
        // тело конструктора
    }
    ...
    [cпецификатор] [модификатор] имя_конструктораN (список параметров)
    { 
        // тело конструктора
    }
    
// объявление методов
    [cпецификатор] [модификатор] тип имя_метода1(список параметров)
    { 
        // тело метода
    }
}
```

К членам класса относятся:
* константы;
* поля;
* Конструкторы (типа и экземпляра);
* методы;
* перегруженные операторы;
* операторы преобразования;
* свойства;
* события;
* вложенные классы.

Модифиакторы доступа языка C#
---

* модификаторы класса:
  * **`public`** – данные доступны всем методам во всех сборках
  * **`internal`** – данные доступны только методам в сборке

* модификаторы полей:
  * **`private`** – данные доступны только методам внутри класса и вложенных в него классам
  * **`protected`** – данные доступны только методам внутри класса (и вложенным в него классам) или методам из его производных классов
  * **`protected internal`** – данные доступны только методам вложенного или производного типа класса и любым методам сборки

Методы класса
---

* **Передача параметров.**
* **Ключевое слово return.**
* **Перегрузка методов.**

Передача параметров
---

```cs
int i = 0;
int[] myArr = { 0, 1, 2, 4 };

// передаем по значению: i содержит 0, myArr содержит адрес!
MyFunctionByVal1(i, myArr);

Console.WriteLine("i = {0}", i); // 0
Console.WriteLine("MyArr[0] = {0}", myArr[0]); // 100
```

```cs
static void MyFunctionByVal1(int i, int[] MyArr)
{
  //здесь создается копия этого числа
  i = 100;
  // здесь создается копия адреса
  // обращение к 1-ому элементу массива
  MyArr[0] = 100;
}
```

***

```cs
int i = 0;
int[] myArr = { 0, 1, 2, 4 };
// передаем по значению: i содержит 0, myArr содержит адрес!
MyFunctionByVal(i, myArr);

Console.WriteLine("i = {0}", i); // 0
Console.WriteLine("MyArr[0] = {0}", myArr[0]); // 0
```

```cs
static void MyFunctionByVal(int i, int[] MyArr)
{
  // здесь создается копия этого числа
  i = 100;
  // здесь создается новый массив
  myArr = new int[] { 3, 2, 1 };
}
```

***

```cs
int i = 0;
int[] myArr = { 0, 1, 2, 4 };
// передаем по ссылке
MyFunByRef(ref i, ref myArr);

Console.WriteLine("i = {0}", i); // 100
Console.WriteLine("MyArr[0] = {0}", myArr[0]); // 3
```

```cs
static void MyFunByRef(ref int i, ref int[] MyArr)
{

  i = 100;
  myArr = new int[] { 3, 2, 1 };
}
```

Использование модификатора out
---

Значения **`выходных параметров`** должны присваиваться вызываемым методом, они передаются по ссылке. Если **`выходным параметрам`** в вызываемом методе значения **`не присвоены`**, компилятор сообщит об ошибке

```cs
static void Main(string[] args)
{
  int ans;
  Add(10, 20, out ans);
  Console.WriteLine("Значение переменной ans: " + ans);
  Console.ReadKey();
}

static void Add(int x, int у, out int ans)
{
  ans = x + у; // ans должно быть присвоено значение
}
```

Использование модификатора ref
---

Значение первоначально присваивается вызывающим кодом и при желании может быть изменено в вызываемом методе (поскольку данные также передаются по ссылке). Если параметру ref в вызываемом методе значение не присвоено, никакой ошибки компилятор не генерирует

```cs
static void Main()
 {
  // передаваемые значения по ссылке должны быть проинициализированы
  string str1 = "Первый ";
  string str2 = "Второй ";
  Console.WriteLine("До вызова метода: {0}, {1} ", str1, str2);
  // передача значений str1 и str2 по ссылке
  Metod(ref str1, ref str2);
  Console.WriteLine("После вызова метода: {0}, {1} ", str1, str2);
}

static void Metod(ref string s1, ref string s2)
{
  string tempStr = s1;
  s1 = s2;
  s2 = tempStr;
}
```

Создание методов с переменным количеством аргументов.
---

```cs
static void Main(string[] args)
{
 Console.WriteLine(Metod(1, 2, 3, 4, 5));
 Console.WriteLine(Metod(1, 2, 3, 4, 5,6,7,8,9,10));
 Console.WriteLine(Metod(new int []{5, 6, 7, 8}));
}
// метод с переменным количеством аргументов
// params - должен быть последним и только одним
public static int Metod(params int [] mas)
{
 return mas.Length;
}
```

Перегрузка методов
---

```cs
// перегрузка метода (два параметра типа int) допускается!
public static int Sum(int a, int b)
{
  return a + b;
}

// перегрузка метода (три параметра типа int) допускается!
public static int Sum(int a, int b, int c)
{
  return a + b + c;
}

// перегрузка метода (два параметра типа double) допускается!
public static double Sum(double a, double b)
{
 return a + b;
}

перегрузка метода НЕ допускается! (два параметра типа double, но тип возврата string)
//public static string Sum(double a, double b)
//{
// return (a + b).ToString();
//}
```

Конструкторы
---

* **Понятие конструктора.**
* **Параметризованный конструктор.**
* **Перегруженные конструкторы.**
* **Статические конструкторы.**

**`Конструктор класса`** - специальный метод, который предназначен для инициализации полей класса и вызывается при построении экземпляра класса

![](https://pp.userapi.com/c840536/v840536690/65d1/BwMyrxC9ZbE.jpg)

Задача `конструктора по умолчанию` – инициализация полей значениями по умолчанию.
Задача `пользовательского конструктора` – инициализация полей предопределенными пользователем значениями.

![](https://pp.userapi.com/c841335/v841335690/1c0e8/7j8qTsIt-Cc.jpg)

Сцепление конструкторов или цепочка конструкторов
---

```cs
// Конструктор без параметров
  public Car() : this("Нет водителя")
  { }
// Конструктор с одним параметром
  public Car(string driverName) : this(driverName, 0)
  { }
// Конструктор с параметрами
  public Car(string driverName, int speed)
  {
      this.driverName = driverName;
      this.currSpeed = speed;
  }

/ ** /

Console.WriteLine("Конструктор по умолчанию");
Car myCar = new Car();
myCar.PrintState();
// Вывод – Нет водителя, скорость=0

Console.WriteLine("Конструктор с параметрами");
myCar = new Car("Рубенс Барикелло", 50);
myCar.PrintState();
// Вывод – Рубенс Барикелло, скорость = 50
```

Конструктор копии
---

```cs
class Person
  {
    public int Age;
    public string Name;
 
 // Конструтор экземпляра
    public Person(string name, int age)
    {
      Name = name; Age = age;
    }
    
 // конструктор копии
    public Person(Person prevPerson)
    { 
      Name = prevPerson.Name; Age = prevPerson.Age;
    }
}

/ ** /

// Создание объекта класса Person
Person person1 = new Person("Иван", 40);
// Создание копии объекта person1
Person person2 = new Person(person1);
// Изменение значений
person1.Age = 39;
person2.Age = 41;
person2.Name = "Андрей";
```

Свойства
---

Свойство это конструкция языка C#, которая заменяет собой использование обычных методов доступа.

Работа со свойством экземпляра напоминает работу с полями экземпляра.





***

[**-->     HomeWork4     <--**]()

**07.09.2017**

[**<-- Массивы и строки**](https://github.com/SuvStreet/IT_Step_C_Sharp/tree/master/ClassWork/Day3#Массивы-и-строки) `=/=` [**Исключения (Exceptions) -->**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/ClassWork/Day5/README.md#Исключения-exceptions)
