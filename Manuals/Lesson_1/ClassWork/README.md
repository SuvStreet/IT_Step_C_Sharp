> **Материал взят с методички по курсу "Платформа Microsoft.NET и язык программирования С#". Учебное заведение "Компьютерная Академия Шаг".**

># Содержание
>### [**1 Введение в платформу Microsoft .NET**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#1-Введение-вплатформу-microsoft-net)
>### [**2 Базовые понятия платформы Microsoft .NET**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#2-Базовые-понятия-платформы-microsoft-net)
>### [**3 Введение в язык программирования C#**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#3-Введение-вязык-программирования-c)
>### [**4 Рефлекторы и дотфускаторы**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#4-Рефлекторы-и-дотфускаторы)
>### [**5 Типы данных**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#5-Типы-данных)
>### [**6 Nullable типы**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#6-nullable-типы)
>### [**7 Литералы**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#7-Литералы)
>### [**8 Переменные**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#8-Переменные)
>### [**9 Ввод-вывод в консольном приложении**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#9-Ввод-вывод--в-консольном-приложении)
>### [**10 Структурные и ссылочные типы**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#10-Структурные-и-ссылочные-типы)
>### [**11 Преобразование типов**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#11-Преобразование--типов)
>### [**12 Операторы**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#12-Операторы)
>### [**13 Условия**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#13-Условия)
>### [**14 Циклы**](https://github.com/SuvStreet/IT_Step_C_Sharp/blob/master/Manuals/Lesson_1/ClassWork/README.md#14-Циклы)

1 Введение в платформу Microsoft .NET
===

### История и этапы развития технологий программирования

Первым языком семейства "C" был язык программирования **`"С"`**, разработанный Дэнисом Ритчи в 1970-х годах. До языка «С» программирование в основном было императивным, что вызывало сложности при увеличении «размера» («масштабы») программных проектов.

Следующим этапом развития семейства языков «С» стал язык **`«С++»`**, разработанный Бьярном Страуструпом в 1979-ом году, который реализовывал парадигму объектно-ориентированного подхода в программировании. Тесное родство «С++» и «С» обеспечило популярность новому языку программирования, поскольку «С»-программисту не нужно было изучать новый язык программирования, достаточно было освоить «новые» объектно-ориентированные возможности и без того удачного языка.

Но время предъявило новые требования в области разработки программного обеспечения. Они заключались в том, что у конечного потребителя возникала необходимость в межплатформенной переносимости программного обеспечения, упрощения передачи проектов по сетям коммуникации, а так же в уменьшении времени, которое затрачивается на разработку программного обеспечения.

В 1991 году компания Sun Microsystems предложила решение этой проблемы на базе своего нового языка «Oak» (англ. Дуб), который впоследствии стал называться **`«Java»`**. Авторство этого языка приписывают Джеймсу Гослингу. 

Язык **`C#`** появился в 2000 году и стал основой новой стратегии развития компании Microsoft. Главным архитектором этого языка является Андерс Хейлсберг (он же в 1980-х годах был автором Turbo Pascal).

C# стал потомком языков C, C++ и Java. Можно даже сказать, что он стал их эволюционным продолжением, объединив в себе основные преимущества и доработав положительные стороны описанных языков.

2 Базовые понятия платформы Microsoft .NET
===

### Архитектура платформы Microsoft .NET

Платформа .NET базируется на двух основных компонентах: **Common Language Runtime и .NET Framework Class Library**.

**`CLR (Common Language Runtime`**, общеязыковая среда исполнения) — является основой, исполняющей приложения .NET, обычно написанные на **`CIL (Common Intermediate Language`** — общий промежуточный язык).

**`.NET Framework Class Library (FCL)`** — универсальный набор классов, для использования в разработке программ, так же называют **`BCL (англ. Base Class Library`** — Библиотека Базовых Классов).

CLR является одной из реализаций спецификации общеязыковой инфраструктуры (**`Common Language Infrastructure, сокращенно CLI`**).

CLI — это международная спецификация, которая позиционирует идеологию языков программирования с интегрированной средой исполнения. Основной идеей является то, что приложение, имеющее составные модули, созданные на различных высокоуровневых языках программирования, переводятся не в исполняемый машинный код, а в некоторый промежуточный код.

Основными составляющими CLI являются:
* **Общая система типов (Common Type System, CTS)** - обеспечивает кросс-языковое взаимодействие в рамках среды .NET
* **Виртуальная система исполнения (Virtual Execution System, VES)** — обеспечивает загрузку и выполнение программ, написанных для CLI
* **Система метаданных (Metadata System)** — служит для описания типов, используется для передачи типовой информации между различными инструментами
* **Общий промежуточный язык (Common Intermediate Language, CIL)** — независимый от конкретной платформы байт-код, который выступает в роли целевого языка для любого CLI-совместимого компилятора
* **Общая спецификация языков (Common Language Specification, CLS)** — набор соглашений между разработчиками языков программирования и разработчиками библиотек классов, в которых определено подмножество CTS и набор правил, направленных на обеспечение взаимодействия программ и библиотек, написанных на различных СLI-совместимых языках

FCL включает в себя следующие пространства имён (Namespaces):
* **System** — Это пространство имён включает базовые типы, такие как String, DateTime, Boolean, и другие. Обеспечивает необходимым набором инструментов для работы с консолью, математическими функциями, и базовыми классами для атрибутов, исключений и массивов
* **System.CodeDom** — Обеспечивает возможность создавать код и запускать его
* **System.Collections** — Определяет множество общих контейнеров или коллекций, используемых в программировании — такие как список, очередь, стек, хеш-таблица и некоторые другиеܳ Также включена поддержка обобщений (Generics)
* **System.ComponentModel** — Обеспечивает возможность реализовывать поведение компонентов во время выполнения и во время дизайна. Содержит инфраструктуру для реализации универсальных переносимых компонентов
* **System.Configuration** — Содержит компоненты для управления конфигурационными данными
* **System.Data** — Это пространство имён представляет архитектуру ADO.NET, являющуюся набором программных компонентов, которые могут быть использованы для доступа к данным и для обслуживания данных
* **System.Deployment** — Позволяет настроить способ обновления и распространения приложения с использованием технологии ClickOnce
* **System.Diagnostics** — Предоставляет возможность диа-гностировать разрабатываемое приложение. Включает журнал событий, счётчики производительности, трассировку и взаимодействие с системными процессами
* **System.DirectoryServices** — Обеспечивает лёгкий доступ к Active Directory из управляемого кода
* **System.Drawing** — Предоставляет доступ к GDI+, включая поддержку для двухмерной растровой и векторной графики, изображений, печати и работы с текстом
* **System.Globalization** — Предоставляет помощь для написания интернационализированных приложений. Может быть определена информация, связанная с культурой, включая язык, страну/регион, календарь, шаблоны формата даты, валюты и цифр
* **System.IO** — Позволяет осуществлять считывание и запись в различные потоки, такие как файлы и другие потоки данных. Также обеспечивает взаимодействие с файловой системой
* **System.Management** — Предоставляет средства для запроса информации, такой как количество свободного места на диске, информации о процессоре, к какой базе данных подключено определённое приложение, и многое другое
* **System.Media**  — Позволяет проигрывать системные звуки и файлы мультимедиа
* **System.Messaging**  — Позволяет отображать и  управ-лять очередью сообщений в сети, а также отсылать, принимать и просматривать сообщения. Другое имя для некоторых предоставленных возможностей — .Net Remoting. Это пространство имён заменено Windows Communication Foundation
* **System.Net** — Предоставляет интерфейс для многих протоколов, используемых в сетях в настоящее время, таких как HTTP, FTP, и SMTP. Безопасность общения поддерживается протоколами наподобие SSL
* **System.Linq** — Определяет интерфейс `IQueryable<T>` и связанные с ним методы, которые позволяют подключать провайдеры LINQ
* **System.Linq.Expressions** — Позволяет делегатам и лямбда-выражениям быть представленными как деревья выражений, так, что высокоуровневый код может быть просмотрен и обработан во время его выполнения
* **System.Reflection** — Обеспечивает объектное представление типов, методов и свойств (полей). Предоставляет возможность динамически создавать и вызывать типы. Открывает API для доступа к возможностям рефлексивного программирования в CLR
* **System.Resources** — Позволяет управлять различными ресурсами в приложении, используемыми, в частности, для интернационализации приложения на разных языках
* **System.Runtime** — Позволяет управлять поведением приложения или CLR во время выполнения. Некоторые из включённых возможностей взаимодействуют с COM, сериализированными объектами внутри двоичного файла или SOAP
* **System.Security** — Предоставляет функциональности внутренней системы безопасности CLR. Это пространство имён позволяет разрабатывать модули безопасности для приложений, базирующиеся на политиках и  разрешениях. Обеспечивает доступ к средствам криптографии
* **System.ServiceProcess** — Позволяет создавать приложения, запускаемые как сервисы в системе Windows
* **System.Text** — Поддерживает различные кодировки, регулярные выражения, и другие полезные механизмы для работы со строками (класс StringBuilder)
* **System.Threading** — Облегчает многопоточное программирование и синхронизацию потоков
* **System.Timers**  — Позволяет вызвать событие через определённый интервал времени
* **System.Transactions** — Обеспечивает поддержку локальных и распределённых транзакций. Кроме того, в современных версиях .NET поддерживаются следующие расширения
* **Windows Presentation Foundation** — для создания богатых пользовательских интерфейсов
* **Windows Communication Foundation** — для простого создания сетевых приложений
* **Windows Workflow Foundation** — для управления процессами выполнения
* **Windows CardSpace** — для поддержки технологии «единого входа»

При чтении литературы или посещении различных форумов Вы, наверняка, помимо аббревиатуры CIL встретите ещё два возможных варианта: **IL (Intermediate Language)**, то есть просто «промежуточный язык» или **MSIL (Microsoft Intermediate Language)** это устаревшее название, которое было изменено после выхода стандарта ECMA-335

### Схема компиляции и исполнения приложения платформы Microsoft .NET

![](https://pp.userapi.com/c845324/v845324783/80851/h-_iHYB53Go.jpg)

### Понятия метаданных, манифеста, сборки

При преобразовании программного кода приложения в промежуточный код, еще формируется и блок, так называемых **метаданных**, который содержит информацию о данных, используемых в программе.

В частности, метаданные используются для:
* **сохранения информации о типах.** При компиляции теперь не требуются заголовочные и библиотечные файлы. Всю необходимую информацию компилятор читает непосредственно из управляемых модулей;
* **верификации** (проверки) кода в процессе выполнения модуля;
* **управления динамической памятью** (освобождение памяти) в процессе выполнения модуля;
* **обеспечения динамической подсказки** (IntelliSence) при разработке программы стандартными инструментальными средствами (Microsoft Visual Studio .NET) на основе метаданных.

**Сборка** (Assembly) — базовый строительный блок приложения в .NET Framework. Сборка может быть либо исполняемым приложением (при этом она размещается в файле с расширением .exe), либо библиотечным модулем (в файле с расширением .dll).

**Манифест (Manifest)** или **Декларация сборки** — составная часть сборки. Это еще один набор таблиц метаданных, который:
* идентифицирует сборку в виде текстового имени, ее версию, культуру и цифровую сигнатуру (если сборка распределяется среди приложений);
* определяет входящие в состав файлы (по имени и хэшу);
* указывает типы и ресурсы, существующие в сборке, включая описание тех, которые экспортируются из сборки;
* перечисляет зависимости от других сборок;
* указывает набор прав, необходимых сборке для корректной работы.

3 Введение в язык программирования C#
===

### Дисциплины с использованием языка C#

* **Windows Forms** — технология создания клиентских приложений Windows;
* **Windows Presentation Foundation (WPF)** — технология создания клиентских приложений с гораздо большими возможностями и имеющими более насыщенный дизайн чем в Windows Forms;
* **ADO.NET** — технология, позволяющая работать с базами данных из приложений;
* **SP** — системное программирование, в ходе этой дисциплины изучается работа с потоками и все что с этим связано;
* **NP** — сетевое программирование — изучаются способы передачи информации по сети с использованием различных протоколов;
* **Windows Communication Foundation (WCF)** — сервис-ориентированная технология разработки приложений (создание и применение сервисов);
* **ASP.NET** — технология создания web-приложений.

### Простейшая программа на языке программирования C#

```cs
using System;

namespace ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Введите Ваше имя");
            string name;
            name = Console.ReadLine();
            if (name == "")
                Console.WriteLine("Здравствуй, мир!");
            else
                Console.WriteLine("Здравствуй, " + name + "!");
            Console.ReadKey();
        }
    }
}
```

4 Рефлекторы и дотфускаторы
===

### Что такое рефлектор?

Использование рефлектора предоставляет возможность увидеть, как выглядит сборка после её компиляции.

### Что такое дотфускатор?

Открытый код можно защитить. Для этой цели были созданы программные продукты под общим названием дотфускаторы (dotfuscators). Название дотфускатор происходит из названия основного подхода к защите программных решений — обфускации (obfuscation) или в переводе на русский язык — запутывания.

5 Типы данных
===

Технология .NET Framework определяет две группы типов данных: значимые типы (*value-types*) и ссылочные типы (*reference-types*). Определено, что экземпляры значащих типов должны располагаться в стеке, тогда как ссылочных — в другой области оперативной памяти, называемой управляемой кучей (managed heap). Для описания значимых типов данных используются структуры. Тогда как для описания ссылочных — классы.

![](https://pp.userapi.com/c848632/v848632531/c6d2/OZ72cYg1mCc.jpg)

### Символьный тип данных

```cs
/*Описание действия метода:                     Результат:*/
//определяет является ли символ управляющим
Console.WriteLine(char.sControl('\t'));         //True
//определяет является ли символ цифрой
Console.WriteLine(char.IsDigit('5'));           //True
//определяет является ли символ бувенным
Console.WriteLine(char.IsLetter('x'));          //True
//определяет находится ли символ в нижнем регистре
Console.WriteLine(char.IsLower('m'));           //True
//определяет находится ли символ в верхнем регистре
Console.WriteLine(char.IsUpper('P'));           //True
//определяет является ли символ числом
Console.WriteLine(char.IsNumber('2'));          //True
//определяет является ли символ разделителем
Console.WriteLine(char.IsSeparator('.'));       //False
//определяет является ли символ специальным символом
Console.WriteLine(char.IsSymbol('<'));          //True
//определяет является ли символ пробелом
Console.WriteLine(char.IsWhiteSpace(' '));      //True
//переводит символ в нижний регистр
Console.WriteLine(char.ToLower('T'));           //t
//переводит символ в верхний регистр
Console.WriteLine(char.ToUpper('t'));           //T
```

6 Nullable типы
===

Nullable тип — это тип данных, который помимо значений, лежащего в его основе типа данных, может принимать еще и значение null.

```cs
double number = null; // Ошибка!
string str = null; // запись корректна
```

Чтобы объявить переменную nullable типа, необходимо добавить к имени лежащего в основе типа данных вопросительный знак. Например:

```cs
int? nullInt = null;
nullInt = 10;
bool? nullBool = true;
nullBool = null;
//string? str = null; // ошибка на этапе компиляции
```

### Операции, доступные для nullable типов

Помимо операций, свойственных лежащему в основе типу данных для nullable типов существует еще и специальная операция ?? . Эта операция позволяет присваивать переменной любого типа данных определенное значение, в том случае если текущее значение nullable типа равно null.

```cs
int? nullInt = null;
nullInt = nullInt ?? 50;
Console.WriteLine(nullInt); // 50
int number = nullInt ?? 100;
Console.WriteLine(number); // 50
```

Операция ?? является сокращенной формой записи проверки значения переменной с использованием условного оператора.

```cs
int? nullInt = null;
if (nullInt == null)
{
      nullInt = 100;
}
Console.WriteLine(nullInt); // 100
```

7 Литералы
===

Литералы в С# — это фиксированные значения, которые представлены в понятной форме.

Для явной спецификации типа данных литерала в C# предусмотрены специальные суффиксы. Таким образом, литерал:
* объявленный с суффиксом **«L»** или **«l»** будет иметь тип long;
* с суффиксом **«F»** или **«f»** будет иметь тип float;
* с суффиксом **«D»** или **«d»** будет иметь тип double;
* с суффиксом **«M»** или **«m»** будет иметь тип decimal;
* суффикс **«U»** или **«u»** делает число беззнаковым (суффикс **«U»** может быть объединён с суффиксами, специфицирующими тип данных).

Использование суффиксов демонстрируется на следующем примере:

```cs
/*при помощи метода GetType() программа возвращает тип данных литералов, демонстрируя действие суффиксов*/

Console.WriteLine((10D).GetType());     /*выводит в консоль: System.Double что соответствует типу данных double*/
Console.WriteLine((10f).GetType());     /*выводит в консоль: System.Single что соответствует типу данных float*/
Console.WriteLine((10m).GetType());     /*выводит в консоль: System.Decimal что соответствует типу данных decimal*/
Console.WriteLine((10).GetType());      /*выводит в консоль: System.Int32 что соответствует типу данных int*/
Console.WriteLine((10L).GetType());     /*выводит в консоль: System.Int64 что соответствует типу данных long*/
Console.WriteLine((10UL).GetType());    /*выводит в консоль: System.Uint64 что соответствует типу данных ulong*/
Console.WriteLine(0xFF);                /*выводит в консоль: 255 шестнадцатиричное число 0xFF соответствует десятичному числу 255*/
```

В отдельную группу литералов выделены управляющие символьные последовательности, которые не имеют символьного эквивалента, а преимущественно используются для форматирования текста:

Cимвол  | Действие управляющего символа
--------|--------------------------
`\a`    |   Звуковой сигнал
`\b`    |   Возврат на одну позицию
`\f`    |   Переход к началу следующей страницы
`\n`    |   Новая строка
`\r`    |   Возврат каретки
`\t`    |   Горизонтальная табуляция
`\v`    |   Вертикальная табуляция
`\0`    |   Нуль-символ (символ конца строки)
`\’`    |   Одинарная кавычка
`\”`    |   Двойная кавычка
`\\`    |   Обратная косая черта

Возможно указать режим «буквального» (verbatim) форматирования, при котором можно не переходить на новую строку без использования управляющих символов. В таких строковых литералах всё содержимое интерпретируется как символы (в том числе и управляющие символы). Для этого перед строковым литералом необходимо указать символ '@' (строка  @"hello world"  является буквально отформатированной строкой). Использование строковых литералов демонстрируется на следующем примере:

```cs
Console.WriteLine("Некоторое простое сообщение\nИ 
ещё одно простое сообщение на новой строке");
/*выводит в консоль следующее сообщение:
Некоторое простое сообщение
И ещё одно простое сообщение на новой строке*/
Console.WriteLine("Пример табуляции: " + 
                  "\n1\t2\t3\n4\t5\t6");
/*выводит в консоль следующее сообщение:
Пример табуляции:
1  .2  3
4  .5  6*/
Console.WriteLine(@"Пример буквального 
                  строкового литерала:
1       \t     3
\n   5       6");
/*выводит в консоль следующее сообщение:
Пример буквального строкового литерала:
1      \t     3
\n   5       6*/
```

8 Переменные
===

Переменная — это именованный объект, хранящий значение некоторого типа данных.

Согласно правилам языка С#, при объявлении идентификаторов можно использовать алфавитно-цифровые символы и символ подчёркивания (нижний слеш). Начинаться идентификатор должен с буквы или символа подчёркивания. Недопустимо начинать идентификатор с цифры. Ниже приведены примеры нескольких идентификаторов:

```cs
int SomeVar;    //допустимый идентификатор
int somevar;    //допустимый идентификатор
int _SomeVar;   //допустимый идентификатор
int SomeVar2;   //допустимый идентификатор
int 3_SomeVar;  //не допустимый идентификатор
```

Само собой разуметься, что не разрешается использовать ключевые слова в качестве идентификаторов, однако можно использовать ключевые и зарезервированные слова, предварив их символом `@`. Например:

```cs
int @int;  //допустимый идентификатор
@int = 5;  //допустимый идентификатор
Console.WriteLine(@int); //выводит в консоль: 5
```

Интересно, что в приведённом примере идентификатором является слово " int ", а символ  '@'  игнорируется, играя роль сигнализатора, который указывает, что в данном контексте ключевое слово меняет своё значение.

«Время жизни переменной» начинается с момента её объявления и заканчивается закрывающей фигурной скобкой блока, в котором она была объявлена. 

9 Ввод-вывод  в консольном приложении
===

В системе базовых типов  .NET Framework предусмотрен класс Console, который содержит набор статических методов и свойств, необходимых для осуществления консольного ввода-вывода, и получения служебной информации о консоли. Свойства класса — это методы двунаправленного доступа к полям класса, которые обеспечивают инкапсуляцию внутри типа внутренней логики доступа к данным (свойства также называют методами- аксессорами — от английского "access", то есть «доступ»).

В классе Console определены следующие свойства:

* BackgroundColor — возвращает или устанавливает фоновый цвет выводимого в консоль текста (возвращает объект перечисления ConsoleColor)
* BufferHeight — возвращает или устанавливает высоту буферной зоны
* BufferWidth — возвращает или устанавливает ширину буферной зоны
* CapsLock  —  возвращает  true,  если  нажата  клавиша CapsLock
* CursorLeft — возвращает или устанавливает номер колонки буферной зоны, в которой находиться курсор
* CursorSize  —  возвращает  или  устанавливает  высоту курсора относительно высоты ячейки символа
* CursorTop — возвращает или устанавливает номер ряда буферной зоны, в которой находиться курсор
* CursorVisible — возвращает или устанавливает значение индикатора видимости курсора
* Error — возвращает стандартный поток для вывода информации о возникающих ошибках (релевантен cerr в С++)
* ForegroundColor — возвращает или устанавливает цвет выводимого в консоль текста (возвращает объект перечисления ConsoleColor)
* In — возвращает стандартный поток ввода
* InputEncoding — возвращает или устанавливает значение кодировки текста, которую консоль использует для чтения вводимой информации
* KeyAvailable  —  возвращает  true,  если  в  стандартном потоке ввода доступна реакция на нажатие клавиш клавиатуры
* LargestWindowHeight — возвращает наибольшее количество рядов в буферной зоне консоли, базируясь на значениях текущего шрифта и разрешения экрана
* LargestWindowWidth — возвращает наибольшее количество колонок в буферной зоне консоли, базируясь на значениях текущего шрифта и разрешения экрана
* NumberLock — возвращает true, если нажат NUM LOCK
* Out — возвращает стандартный поток вывода
* OutputEncoding — возвращает или устанавливает значение кодировки текста, которую консоль использует для форматирования выводимой информации
* Title — возвращает или устанавливает текст заголовка окна консоли
* TreatControlCAsInput — возвращает индикатор того, как используется комбинация клавиш Ctrl+C: является комбинацией  прерывающей  выполнение  текущего действия в консоли (обрабатываемой системой) или передаётся в стандартный поток ввода
* WindowHeight — возвращает или устанавливает ширину окна консоли
* WindowLeft — возвращает или устанавливает отступ окна консоли слева, относительно экрана
* WindowTop  —  возвращает  или  устанавливает  отступ окна консоли сверху, относительно экрана
* WindowWidth — возвращает или устанавливает высоту окна консоли

Далее будут перечислены статические методы класса Console, специфичные для консольного ввода-вывода:

* Beep — проигрывает звук указанной частоты на протяжении указанного времени
* Clear — очищает буфер консоли и окно консоли от теста
* MoveBufferArea — копирует указанную область буфера консоли в указанную позицию
* OpenStandardError — открывает стандартный поток вывода ошибок с указанным размером буфера
* OpenStandardInput — открывает стандартный поток ввода с указанным размером буфера
* OpenStandardOutput  —  открывает стандартный поток вывода с указанным размером буфера
* Read — читает следующий символ из стандартного 
потока ввода .
* ReadKey — получает информацию о нажатой пользователем клавише (объект класса  ConsoleKeyInfo )
* ReadLine — возвращает следующую строку текста из стандартного потока ввода
* ResetColor — устанавливает значение цвета текста в значение по умолчанию
* SetBufferSize — устанавливает высоту и ширину буфера консоли
* SetCursorPosition — устанавливает позицию курсора
* SetError — передаёт объект класса  System.IO.TextWriter, указанный в качестве параметра, в качестве значения свойства Error
* SetIn — передаёт объект класса  System.IO.TextReader, указанный в качестве параметра, в качестве значения свойства In
* SetOut — передаёт объект класса  System.IO.TextWriter, указанный в качестве параметра, в качестве значения 
свойства Out
* SetWindowPosition — устанавливает позицию окна консоли относительно экрана
* SetWindowSize — устанавливает размер окна консоли
* Write — осуществляет вывод информации в стандартный поток вывода
* WriteLine — аналогично методу Write, за исключением того, что данный метод дополняет выводимую строку служебным символом «\n» (переводит текст на следующую строку) .

Следующий пример демонстрирует использование некоторых из описанных выше методов и свойств:

```cs
using System;
namespace ConsoleInputOutput
{
    class Program
    {
        static void Main(string[] args)
        {
            //изменяет заголовок окна консоли
            Console.Title = "Пример использования 
            инструментов класса Console";
            Console.BackgroundColor = ConsoleColor.
White; //изменяет цвет фона
            //изменяет цвет текста
            Console.ForegroundColor = ConsoleColor.
DarkGreen;
            //получаем размер самого длинного
            сообщения в рамках нашей программы
            int length = ("Input Encoding: " +
  Console.InputEncoding.ToString()).
Length+1;
            Console.SetWindowSize(length, 8); 
            //устанавливаем размер окна консоли
            /*устанавливаем размер буфера консоли 
            (размер окна должен быть 
            соответствующим и должен быть 
            установлен до того, как мы изменим 
            размер буфера)*/
            Console.SetBufferSize(length, 8);
            //выводим информацию о кодировке потока 
            ввода
            Console.WriteLine("Input Encoding: " +
            Console.InputEncoding.ToString());
            //выводим информацию о кодировке потока
            вывода
            Console.WriteLine("Output Encoding: " +
            Console.OutputEncoding.ToString());
            //устанавливает зеначение цвета текста 
            в значение по умолчанию
            Console.ResetColor();
            //выводим информацию о том, нажат ли 
            NUM LOCK
            Console.WriteLine("Is NUM LOCK turned 
            on: " +
            Console.NumberLock.ToString());
            //выводим информацию о том, нажат ли 
            CAPS LOCK
            Console.WriteLine("Is CAPS LOCK turned 
            on: " +
            Console.CapsLock.ToString());
            /*выводим пользователю сообщение 
            о том, что программа ожидает ввода
            некоторой информации*/
            Console.Write("Enter a simpe message: 
            ");
            //получаем от пользователя текстовое
            сообщение
            string message = Console.ReadLine();
            //выводим сообщение, введённое
            пользователем
            Console.WriteLine("Your message is: " 
            + message);
        }
    }
}
```

10 Структурные и ссылочные типы
===

Как уже упоминалось выше, в С# определены две категории типов данных:

* **Структурные  типы  данных  или  значимые  типы (value-types)**;
* **Ссылочные (referenced-types)**.

11 Преобразование  типов
===

Преобразование типов (приведение типов) — это процесс перевода значения объекта из одного типа данных в другой. Отличают две формы приведения типов:
* **неявное (implicit)** приведение (компилятор самостоятельно определяет — к какому типу данных необходимо привести значение);
* **явное (explicit)** приведение (тип, к которому нужно привести значение, «явно» указан разработчиком).

Существуют правила приведения типов. Не все типы данных приводимы друг к другу .

Согласно официальной документации, указанные ниже методы класса  Convert  реализуют следующее поведение:

* ToBase64CharArray — Преобразует значение подмножества массива 8-битовых целых чисел без знака в эквивалентное подмножество массива знаков Юникода, состоящее из цифр в кодировке Base64.
* ToBase64String — Преобразует значение массива 8-битовых целых чисел без знака в эквивалентное представление в виде значения типа  String , состоящее из цифр в кодировке Base64.
* ToBoolean — Преобразует заданное значение в эквивалентное логическое значение.
* ToByte — Преобразует заданное значение в 8-битовое целое число без знака.
* ToChar — Преобразует заданное значение в символ Юникода.
* ToDateTime — Преобразует заданное значение к типу DateTime.
* ToDecimal — Преобразует заданное значение в число типа Decimal.
* ToDouble — Преобразует заданное значение в число двойной точности с плавающей запятой.
* ToInt16 — Преобразует заданное значение в 16-битовое целое число со знаком.
* ToInt32 — Преобразует заданное значение в 32-битовое целое число со знаком.
* ToInt64 — Преобразует заданное значение в 64-битовое целое число со знаком.
* ToSByte — Преобразует заданное значение в 8-битовое целое число со знаком.
* ToSingle  —  Преобразует  заданное  значение  в  число одинарной точности с плавающей запятой.
* ToString — Преобразует заданное значение в эквива-лентное представление в виде значения типа  String .
* ToUInt16 — Преобразует заданное значение в 16-бито-вое целое число без знака.
* ToUInt32 — Преобразует заданное значение в 32-бито-вое целое число без знака.
* ToUInt64 — Преобразует заданное значение в 64-бито-вое целое число без знака.

12 Операторы
===

Операторы — это лексемы, которые на уровне языка программирования являются псевдонимами некоторых операций (как правило, «примитивных»).

Операторы необходимы для упрощения формулировки выражений включающих базовые операции . Например, математических выражений:

```cs
//объявление локальных переменных
int x = 5, y = 6, j = 7, z = 4;
//выполнение вычислений с использованием операторов
int result = (x + y) / j * z;
Console.WriteLine(result); // результат выполнения: 4
```

Ниже приведены категории операторов языка программирования C#:

Категории операторов                    |  Операторы
----------------------------------------|------------------------
Арифметические                          |   `+   -   *   /   %`
Логические (булевы и побитовые)         |   `&   |   ^   !   ~   &&   ||   true   false`
Инкремент, декремент                    |   `++   --`
Сдвиг                                   |   `<<   >>`
Операторы отношения                     |   `==   !=   <   >   <=   >=`
Операторы инициализации (присваивания)  |   `=   +=   -=   *=   /=   %=   &=   |=   ^=   <<=   >>=`
Доступ к компоненту класса (объекта)    |   `.`
Индексатор                              |   `[]`
Ограничитель блока                      |   `()`
Условный (тернарный) оператор           |   `?:`
Добавление и удаление делегата          |   `+   -`
Создание объекта                        |   `new`
Получение информации о типе данных      |   `as   is   sizeof   typeof`
Контроль ошибки переполнения            |   `checked   unchecked`
Получение адреса и разыменование        |   `*   ->   []   &`

13 Условия
===

Условие — это логическое выражение (выражение, результатом которого является логическое значение), которое используется для реализации алгоритма ветвления.

```cs
a > b                       // простое  условие
a > b && b > c || x == y    // составное условие
```

### Условный оператор if

```cs
if    (Условное Выражение)
{  
      Действие; 
}
```

### Условный оператор if else

```cs
if (Условное Выражение)
{
    //Действия 1; 
}
else
{
    //Действия 2; 
}
```

### Условный оператор switch

```cs
switch (выражение) 
{
    case константа 1:
         //блок операторов первой константы;
         break;
    сase константа 2:
         //блок операторов второй константы;
         break;
    case константа n:
         //блок операторов n-й константы;
         break;
         default: 
         //операторы, выполняющиеся в том случае, 
         //когда значение выражения не совпало 
         //ни с одним из перечисленных значений 
         //констант;
    break;
}
```

### Тернарный оператор ?:

```cs
Условие ? выражение№1 : выражение№2
```

14 Циклы
===

В зависимости от того, когда выполняется проверка условия выхода, циклы делят на:
* циклы с предусловием (условие проверяется до того, как будет выполнено тело цикла);
* циклы с постусловием (условие проверяется после того, как выполняется тело цикла).

По наличию в цикле итератора, выделяют:
* Циклы со счётчиком;
* Циклы без счётчика .

По наличию условия выхода выделяют:
* Условные циклы;
* Безусловные или бесконечные циклы .

### Цикл for

```cs
for (инициализация_переменных; условное_выражение; 
выражение)// Заголовок цикла;
{
    // Тело цикла;
}
```

### Цикл while

```cs
while (условное_выражение)
    {
         Действие;
}
```

### Цикл do while

```cs
do
{
     Действие;
}
while (выражение);
```

### Цикл foreach

```cs
foreach(тип_переменной идентификатор in контейнер) 
{
    Действие;
}
```

### Инструкция break

Инструкция «break» используется для прерывания выполнения всего цикла.

```cs
int i = 0;
    while (true)
    {
         if (++i % 6 == 0)
         {
              Console.WriteLine(i);
         }
         if (i == 100)
         {
              break;
         }
    }
```

### Инструкция continue

Инструкция «continue» используется для прекращения выполнения текущей итерации цикла и перехода к следующей.

```cs
for (int i = 1; i < 20; i++)
{
    if (i % 2 != 0)
    {
        continue;
    }
    Console.WriteLine(i);
}
```
